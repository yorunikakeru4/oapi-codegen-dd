// Code generated by oapi-codegen. DO NOT EDIT.
package models

import (
	"context"
	"encoding/json"
	"net/http"

	"github.com/doordash-oss/oapi-codegen-dd/v3/pkg/runtime"
	"github.com/go-chi/chi/v5"
)

// ServiceInterface defines the service interface for business logic.
type ServiceInterface interface {
	// HealthCheck Health check endpoint
	HealthCheck(ctx context.Context) (*HealthCheckResponseData, error)
	// ListUsers List all users
	ListUsers(ctx context.Context, opts *ListUsersServiceRequestOptions) (*ListUsersResponseData, error)
	// CreateUser Create a new user
	CreateUser(ctx context.Context, opts *CreateUserServiceRequestOptions) (*CreateUserResponseData, error)
	// GetUser Get a user by ID
	GetUser(ctx context.Context, opts *GetUserServiceRequestOptions) (*GetUserResponseData, error)
	// DeleteUser Delete a user
	DeleteUser(ctx context.Context, opts *DeleteUserServiceRequestOptions) (*DeleteUserResponseData, error)
}

// HTTPAdapter adapts the ServiceInterface to HTTP handlers.
// This struct is generated and should not be modified.
type HTTPAdapter struct {
	svc        ServiceInterface
	errHandler OapiErrorHandler
}

// NewHTTPAdapter creates a new HTTPAdapter wrapping the given service.
// If errHandler is nil, OapiDefaultErrorHandler is used.
func NewHTTPAdapter(svc ServiceInterface, errHandler OapiErrorHandler) *HTTPAdapter {
	if errHandler == nil {
		errHandler = &OapiDefaultErrorHandler{}
	}
	return &HTTPAdapter{svc: svc, errHandler: errHandler}
}

// HealthCheck handles GET /health
func (a *HTTPAdapter) HealthCheck(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Call business logic
	resp, err := a.svc.HealthCheck(ctx)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// ListUsers handles GET /users
func (a *HTTPAdapter) ListUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &ListUsersServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &ListUsersQuery{}
	query := r.URL.Query()
	if queryParamLimitStr := query.Get("limit"); queryParamLimitStr != "" {
		queryParamLimit, err := runtime.ParseString[int](queryParamLimitStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ListUsers",
				Message:       err.Error(),
				ParamName:     "limit",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Limit = &queryParamLimit
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.ListUsers(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// CreateUser handles POST /users
func (a *HTTPAdapter) CreateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &CreateUserServiceRequestOptions{}
	opts.RawRequest = r

	// Parse request body
	defer r.Body.Close()
	var body CreateUserBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "CreateUser",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.CreateUser(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 201
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetUser handles GET /users/{id}
func (a *HTTPAdapter) GetUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetUserServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetUserPath{}
	pathParamIDStr := chi.URLParam(r, "id")
	pathParams.ID = pathParamIDStr
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetUser(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// DeleteUser handles DELETE /users/{id}
func (a *HTTPAdapter) DeleteUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &DeleteUserServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &DeleteUserPath{}
	pathParamIDStr := chi.URLParam(r, "id")
	pathParams.ID = pathParamIDStr
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.DeleteUser(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 204
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.WriteHeader(status)
}
