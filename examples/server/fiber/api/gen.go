// Code generated by oapi-codegen. DO NOT EDIT.

package api

import (
	"context"
	"encoding/json"
	"net/http"

	"github.com/doordash-oss/oapi-codegen-dd/v3/pkg/runtime"
	"github.com/go-playground/validator/v10"
	fiber "github.com/gofiber/fiber/v3"
	"github.com/gofiber/fiber/v3/middleware/adaptor"
)

// OapiErrorKind represents the type of error that occurred during request processing.
type OapiErrorKind int

const (
	// OapiErrorKindParse indicates a parameter parsing error (invalid path/query/header parameter).
	OapiErrorKindParse OapiErrorKind = iota

	// OapiErrorKindDecode indicates a request body decoding error (invalid JSON, form data, etc.).
	OapiErrorKindDecode

	// OapiErrorKindValidation indicates a request validation error (failed schema validation).
	OapiErrorKindValidation

	// OapiErrorKindService indicates a service/business logic error returned by the service implementation.
	OapiErrorKindService
)

// OapiHandlerError represents an error that occurred during request handling (parse, decode, validation).
// When no typed error response is configured in the OpenAPI spec, this error type is used.
// Custom error handlers can type-assert to this type to access error details.
type OapiHandlerError struct {
	Kind          OapiErrorKind
	OperationID   string
	Message       string
	ParamName     string
	ParamLocation string
}

func (e OapiHandlerError) Error() string {
	return e.Message
}

// OapiErrorResponse is the default JSON error response structure used by OapiDefaultErrorHandler.
type OapiErrorResponse struct {
	Error         string `json:"error"`
	OperationID   string `json:"operation_id,omitempty"`
	ParamName     string `json:"param_name,omitempty"`
	ParamLocation string `json:"param_location,omitempty"`
}

// OapiErrorHandler handles errors that occur during request processing.
// Implement this interface to customize error responses, logging, and metrics.
type OapiErrorHandler interface {
	// HandleError writes an error response to w with the given status code.
	// The err is either an OapiHandlerError (for parse/decode/validation errors)
	// or a typed error matching the OpenAPI spec's error response schema.
	HandleError(w http.ResponseWriter, r *http.Request, statusCode int, err error)
}

// OapiDefaultErrorHandler provides the default error handling behavior.
// It writes JSON error responses. For OapiHandlerError, it uses OapiErrorResponse.
// For typed errors (from OpenAPI spec), it encodes them directly.
type OapiDefaultErrorHandler struct{}

// HandleError implements OapiErrorHandler with default JSON error responses.
func (h *OapiDefaultErrorHandler) HandleError(w http.ResponseWriter, r *http.Request, statusCode int, err error) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)

	if handlerErr, ok := err.(OapiHandlerError); ok {
		_ = json.NewEncoder(w).Encode(OapiErrorResponse{
			Error:         handlerErr.Message,
			OperationID:   handlerErr.OperationID,
			ParamName:     handlerErr.ParamName,
			ParamLocation: handlerErr.ParamLocation,
		})
		return
	}

	// Typed error from OpenAPI spec - encode directly
	_ = json.NewEncoder(w).Encode(err)
}

// ServiceInterface defines the service interface for business logic.
type ServiceInterface interface {
	// HealthCheck Health check endpoint
	HealthCheck(ctx context.Context) (*HealthCheckResponseData, error)
	// ListUsers List all users
	ListUsers(ctx context.Context, opts *ListUsersServiceRequestOptions) (*ListUsersResponseData, error)
	// CreateUser Create a new user
	CreateUser(ctx context.Context, opts *CreateUserServiceRequestOptions) (*CreateUserResponseData, error)
	// GetUser Get a user by ID
	GetUser(ctx context.Context, opts *GetUserServiceRequestOptions) (*GetUserResponseData, error)
	// DeleteUser Delete a user
	DeleteUser(ctx context.Context, opts *DeleteUserServiceRequestOptions) (*DeleteUserResponseData, error)
}

// HTTPAdapter adapts the ServiceInterface to HTTP handlers.
// This struct is generated and should not be modified.
type HTTPAdapter struct {
	svc        ServiceInterface
	errHandler OapiErrorHandler
}

// NewHTTPAdapter creates a new HTTPAdapter wrapping the given service.
// If errHandler is nil, OapiDefaultErrorHandler is used.
func NewHTTPAdapter(svc ServiceInterface, errHandler OapiErrorHandler) *HTTPAdapter {
	if errHandler == nil {
		errHandler = &OapiDefaultErrorHandler{}
	}
	return &HTTPAdapter{svc: svc, errHandler: errHandler}
}

// HealthCheck handles GET /health
func (a *HTTPAdapter) HealthCheck(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Call business logic
	resp, err := a.svc.HealthCheck(ctx)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// ListUsers handles GET /users
func (a *HTTPAdapter) ListUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &ListUsersServiceRequestOptions{}
	opts.RawRequest = r

	// Parse query parameters
	queryParams := &ListUsersQuery{}
	query := r.URL.Query()
	if queryParamLimitStr := query.Get("limit"); queryParamLimitStr != "" {
		queryParamLimit, err := runtime.ParseString[int](queryParamLimitStr)
		if err != nil {
			a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
				Kind:          OapiErrorKindParse,
				OperationID:   "ListUsers",
				Message:       err.Error(),
				ParamName:     "limit",
				ParamLocation: "query",
			})
			return
		}
		queryParams.Limit = &queryParamLimit
	}
	opts.Query = queryParams

	// Call business logic
	resp, err := a.svc.ListUsers(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// CreateUser handles POST /users
func (a *HTTPAdapter) CreateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &CreateUserServiceRequestOptions{}
	opts.RawRequest = r

	// Parse request body
	defer r.Body.Close()
	var body CreateUserBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
			Kind:        OapiErrorKindDecode,
			OperationID: "CreateUser",
			Message:     err.Error(),
		})
		return
	}
	opts.Body = &body

	// Call business logic
	resp, err := a.svc.CreateUser(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 201
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// GetUser handles GET /users/{id}
func (a *HTTPAdapter) GetUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &GetUserServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &GetUserPath{}
	pathParamIDStr := r.PathValue("id")
	pathParams.ID = pathParamIDStr
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.GetUser(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 200
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if resp != nil && resp.Body != nil {
		_ = json.NewEncoder(w).Encode(resp.Body)
	}
}

// DeleteUser handles DELETE /users/{id}
func (a *HTTPAdapter) DeleteUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	opts := &DeleteUserServiceRequestOptions{}
	opts.RawRequest = r

	// Parse path parameters
	pathParams := &DeleteUserPath{}
	pathParamIDStr := r.PathValue("id")
	pathParams.ID = pathParamIDStr
	opts.PathParams = pathParams

	// Call business logic
	resp, err := a.svc.DeleteUser(ctx, opts)
	if err != nil {
		code := http.StatusInternalServerError
		a.errHandler.HandleError(w, r, code, err)
		return
	}

	// Apply custom headers from response
	if resp != nil && resp.Headers != nil {
		for k, v := range resp.Headers {
			for _, val := range v {
				w.Header().Add(k, val)
			}
		}
	}

	// Determine status code
	status := 204
	if resp != nil && resp.Status != 0 {
		status = resp.Status
	}
	w.WriteHeader(status)
}

// RouterOption is a function that configures the router.
type RouterOption func(*routerConfig)

type routerConfig struct {
	middlewares []fiber.Handler
	errHandler  OapiErrorHandler
}

// WithMiddleware adds middleware to the router.
func WithMiddleware(mw fiber.Handler) RouterOption {
	return func(cfg *routerConfig) {
		cfg.middlewares = append(cfg.middlewares, mw)
	}
}

// WithErrorHandler sets a custom error handler for the router.
// If not set, OapiDefaultErrorHandler is used.
func WithErrorHandler(h OapiErrorHandler) RouterOption {
	return func(cfg *routerConfig) {
		cfg.errHandler = h
	}
}

// fiberHTTPHandler wraps an http.HandlerFunc with path param injection for Fiber.
func fiberHTTPHandler(h http.HandlerFunc, pathParams ...string) fiber.Handler {
	return func(c fiber.Ctx) error {
		return adaptor.HTTPHandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Copy path params from Fiber context to http.Request
			for _, param := range pathParams {
				r.SetPathValue(param, c.Params(param))
			}
			h(w, r)
		})(c)
	}
}

// NewRouter registers routes on the given Fiber app with the service implementation.
func NewRouter(app *fiber.App, svc ServiceInterface, opts ...RouterOption) {
	cfg := &routerConfig{}
	for _, opt := range opts {
		opt(cfg)
	}

	httpAdapter := NewHTTPAdapter(svc, cfg.errHandler)

	// Apply middleware to all routes
	for _, mw := range cfg.middlewares {
		app.Use(mw)
	}
	app.Get("/health", adaptor.HTTPHandlerFunc(httpAdapter.HealthCheck))
	app.Get("/users", adaptor.HTTPHandlerFunc(httpAdapter.ListUsers))
	app.Post("/users", adaptor.HTTPHandlerFunc(httpAdapter.CreateUser))
	app.Get("/users/:id", fiberHTTPHandler(httpAdapter.GetUser, "id"))
	app.Delete("/users/:id", fiberHTTPHandler(httpAdapter.DeleteUser, "id"))
}

type GetUserPath struct {
	ID string `json:"id" validate:"required"`
}

func (g GetUserPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type DeleteUserPath struct {
	ID string `json:"id" validate:"required"`
}

func (d DeleteUserPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type CreateUserBody = CreateUserRequest

type ListUsersQuery struct {
	Limit *int `json:"limit,omitempty"`
}

// HealthCheckResponseData wraps the success response with optional headers and status override.
type HealthCheckResponseData struct {
	Body    *HealthCheckResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewHealthCheckResponseData creates a new HealthCheckResponseData with the given body.
func NewHealthCheckResponseData(body *HealthCheckResponse) *HealthCheckResponseData {
	return &HealthCheckResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *HealthCheckResponseData) WithHeaders(h http.Header) *HealthCheckResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *HealthCheckResponseData) WithStatus(code int) *HealthCheckResponseData {
	r.Status = code
	return r
}

// ListUsersResponseData wraps the success response with optional headers and status override.
type ListUsersResponseData struct {
	Body    *ListUsersResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewListUsersResponseData creates a new ListUsersResponseData with the given body.
func NewListUsersResponseData(body *ListUsersResponse) *ListUsersResponseData {
	return &ListUsersResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *ListUsersResponseData) WithHeaders(h http.Header) *ListUsersResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *ListUsersResponseData) WithStatus(code int) *ListUsersResponseData {
	r.Status = code
	return r
}

// CreateUserResponseData wraps the success response with optional headers and status override.
type CreateUserResponseData struct {
	Body    *CreateUserResponse
	Headers http.Header
	Status  int // 0 = use default (201)
}

// NewCreateUserResponseData creates a new CreateUserResponseData with the given body.
func NewCreateUserResponseData(body *CreateUserResponse) *CreateUserResponseData {
	return &CreateUserResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *CreateUserResponseData) WithHeaders(h http.Header) *CreateUserResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *CreateUserResponseData) WithStatus(code int) *CreateUserResponseData {
	r.Status = code
	return r
}

// GetUserResponseData wraps the success response with optional headers and status override.
type GetUserResponseData struct {
	Body    *GetUserResponse
	Headers http.Header
	Status  int // 0 = use default (200)
}

// NewGetUserResponseData creates a new GetUserResponseData with the given body.
func NewGetUserResponseData(body *GetUserResponse) *GetUserResponseData {
	return &GetUserResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *GetUserResponseData) WithHeaders(h http.Header) *GetUserResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *GetUserResponseData) WithStatus(code int) *GetUserResponseData {
	r.Status = code
	return r
}

// DeleteUserResponseData wraps the success response with optional headers and status override.
type DeleteUserResponseData struct {
	Body    *struct{}
	Headers http.Header
	Status  int // 0 = use default (204)
}

// NewDeleteUserResponseData creates a new DeleteUserResponseData with the given body.
func NewDeleteUserResponseData(body *struct{}) *DeleteUserResponseData {
	return &DeleteUserResponseData{Body: body}
}

// WithHeaders sets custom headers on the response.
func (r *DeleteUserResponseData) WithHeaders(h http.Header) *DeleteUserResponseData {
	r.Headers = h
	return r
}

// WithStatus overrides the default status code.
func (r *DeleteUserResponseData) WithStatus(code int) *DeleteUserResponseData {
	r.Status = code
	return r
}

type HealthCheckResponse = HealthStatus

type ListUsersResponse []User

type CreateUserResponse = User

type CreateUserErrorResponse = Error

type GetUserResponse = User

type GetUserErrorResponse = Error

// ListUsersServiceRequestOptions holds all parameters for the ListUsers operation.
type ListUsersServiceRequestOptions struct {
	Query *ListUsersQuery
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *ListUsersServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Query != nil {
		if v, ok := any(o.Query).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Query", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// CreateUserServiceRequestOptions holds all parameters for the CreateUser operation.
type CreateUserServiceRequestOptions struct {
	Body *CreateUserBody
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *CreateUserServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.Body != nil {
		if v, ok := any(o.Body).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Body", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// GetUserServiceRequestOptions holds all parameters for the GetUser operation.
type GetUserServiceRequestOptions struct {
	PathParams *GetUserPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *GetUserServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

// DeleteUserServiceRequestOptions holds all parameters for the DeleteUser operation.
type DeleteUserServiceRequestOptions struct {
	PathParams *DeleteUserPath
	// RawRequest provides access to the underlying HTTP request for custom content type handling.
	RawRequest *http.Request
}

// Validate validates all the fields in the options.
func (o *DeleteUserServiceRequestOptions) Validate() error {
	var errors runtime.ValidationErrors

	if o.PathParams != nil {
		if v, ok := any(o.PathParams).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("PathParams", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}

	return errors
}

type HealthStatus struct {
	Status string `json:"status" validate:"required"`
}

func (h HealthStatus) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(h))
}

type User struct {
	ID    string `json:"id" validate:"required"`
	Name  string `json:"name" validate:"required"`
	Email string `json:"email" validate:"required"`
}

func (u User) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(u))
}

type CreateUserRequest struct {
	Name  string `json:"name" validate:"required"`
	Email string `json:"email" validate:"required"`
}

func (c CreateUserRequest) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type Error struct {
	Code    *string `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

func (s Error) Error() string {
	return "unmapped client error"
}

var typesValidator *validator.Validate

func init() {
	typesValidator = validator.New(validator.WithRequiredStructEnabled())
	runtime.RegisterCustomTypeFunc(typesValidator)
}
