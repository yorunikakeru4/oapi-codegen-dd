// Code generated by oapi-codegen. DO NOT EDIT.

package testcase

import (
	"bytes"
	"encoding/json"
	"fmt"
	"time"

	"github.com/doordash-oss/oapi-codegen-dd/v3/pkg/runtime"
	"github.com/go-playground/validator/v10"
)

type OrderStatus string

const (
	Confirmed OrderStatus = "confirmed"
	Delivered OrderStatus = "delivered"
	Pending   OrderStatus = "pending"
	Shipped   OrderStatus = "shipped"
)

// Validate checks if the OrderStatus value is valid
func (o OrderStatus) Validate() error {
	switch o {
	case Confirmed, Delivered, Pending, Shipped:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid OrderStatus value, got: %v", o))
	}
}

type ListUsersHeaders struct {
	// XRequestID Unique request identifier for tracing
	XRequestID string `json:"X-Request-ID" validate:"required"`
}

func (l ListUsersHeaders) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(l))
}

type GetCategoryHeaders struct {
	// XIncludeProducts Include products count (boolean header)
	XIncludeProducts *bool `json:"X-Include-Products,omitempty"`

	// XMaxDepth Max depth for nested categories (integer header)
	XMaxDepth *int `json:"X-Max-Depth,omitempty"`

	// XPriceThreshold Price threshold filter (number header)
	XPriceThreshold *float32 `json:"X-Price-Threshold,omitempty"`
}

type GetUserPath struct {
	ID string `json:"id" validate:"required"`
}

func (g GetUserPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type DeleteUserPath struct {
	ID string `json:"id" validate:"required"`
}

func (d DeleteUserPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(d))
}

type GetUserAvatarPath struct {
	ID string `json:"id" validate:"required"`
}

func (g GetUserAvatarPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type UploadUserAvatarPath struct {
	ID string `json:"id" validate:"required"`
}

func (u UploadUserAvatarPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(u))
}

type GetItemsByTypePath struct {
	Type string `json:"type" validate:"required"`
}

func (g GetItemsByTypePath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetCategoryPath struct {
	CategoryID int `json:"categoryId" validate:"required"`
}

func (g GetCategoryPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetItemsByStatusPath struct {
	Type   string  `json:"type" validate:"required"`
	Rating float32 `json:"rating" validate:"required"`
}

func (g GetItemsByStatusPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type GetUserPostPath struct {
	ID     string `json:"id" validate:"required"`
	PostID string `json:"postId" validate:"required"`
}

func (g GetUserPostPath) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type CreateUserBody = CreateUserRequest

type ImportUsersBody struct {
	// File CSV file with user data
	File runtime.File `json:"file" validate:"required"`

	// Overwrite Overwrite existing users
	Overwrite *bool `json:"overwrite,omitempty"`
}

func (i ImportUsersBody) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(i.File).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("File", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type UploadUserAvatarBody = runtime.File

type SubmitContactFormBody struct {
	Name    string `json:"name" validate:"required"`
	Email   string `json:"email" validate:"required"`
	Message string `json:"message" validate:"required"`
}

func (s SubmitContactFormBody) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type CreateNoteBody = string

type ProcessXMLDataBody = XMLPayload

type GetOAuthTokenBody struct {
	GrantType    string  `json:"grant_type" validate:"required"`
	ClientID     string  `json:"client_id" validate:"required"`
	ClientSecret *string `json:"client_secret,omitempty"`
}

func (g GetOAuthTokenBody) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(g))
}

type UploadImageBody = runtime.File

type CreateOrderBody = CreateOrderRequest

type CreateCompanyBody = CreateCompanyRequest

type ListUsersQuery struct {
	Limit *int `json:"limit,omitempty"`
}

type SearchQuery struct {
	Q string `json:"q" validate:"required"`
}

func (s SearchQuery) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type ListProductsQuery struct {
	// Ids Filter by product IDs (string array)
	Ids []string `json:"ids,omitempty"`

	// Tags Filter by tags (string array)
	Tags []string `json:"tags,omitempty"`

	// CategoryIds Filter by category IDs (integer array)
	CategoryIds []int `json:"categoryIds,omitempty"`

	// MinPrice Minimum price (number/float)
	MinPrice *float32 `json:"minPrice,omitempty"`

	// Active Filter by active status (boolean)
	Active *bool `json:"active,omitempty"`
}

type StatusResponse struct {
	Status *string `json:"status,omitempty"`
	Uptime *int    `json:"uptime,omitempty"`
}

type HealthCheckResponse = string

type ListUsersResponse []User

type CreateUserResponse = User

type CreateUserErrorResponse = Error

type ImportUsersResponse = ImportResult

type GetUserResponse = User

type GetUserErrorResponse = Error

type GetUserAvatarResponse = runtime.File

type GetUserAvatarErrorResponse string

func (r GetUserAvatarErrorResponse) Error() string {
	return "unmapped client error"
}

type SubmitContactFormResponse map[string]any

type CreateNoteResponse = int

type ProcessXMLDataResponse = []byte

type ExportDataResponse = runtime.File

type GetOAuthTokenResponse = TokenResponse

type GetItemsByTypeResponse []string

type SearchResponse struct {
	Search_Response_OneOf *Search_Response_OneOf `json:"-"`
}

func (s SearchResponse) MarshalJSON() ([]byte, error) {
	var parts []json.RawMessage

	{
		b, err := runtime.MarshalJSON(s.Search_Response_OneOf)
		if err != nil {
			return nil, fmt.Errorf("Search_Response_OneOf marshal: %w", err)
		}
		parts = append(parts, b)
	}

	return runtime.CoalesceOrMerge(parts...)
}

func (s *SearchResponse) UnmarshalJSON(data []byte) error {
	trim := bytes.TrimSpace(data)
	if bytes.Equal(trim, []byte("null")) {
		return nil
	}
	if len(trim) == 0 {
		return fmt.Errorf("empty JSON input")
	}

	if s.Search_Response_OneOf == nil {
		s.Search_Response_OneOf = &Search_Response_OneOf{}
	}

	if err := runtime.UnmarshalJSON(data, s.Search_Response_OneOf); err != nil {
		return fmt.Errorf("Search_Response_OneOf unmarshal: %w", err)
	}

	return nil
}

type GetStatusResponse = StatusResponse

type UploadImageResponse struct {
	ID  *string `json:"id,omitempty"`
	URL *string `json:"url,omitempty"`
}

type ListProductsResponse []Product

type GetCategoryResponse = Category

type GetItemsByStatusResponse []string

type GetUserPostResponse = Post

type GetUserPostErrorResponse = NotFoundError

type CreateOrderResponse = Order

type CreateOrderErrorResponse = ValidationError

type CreateOrderErrorResponseJSON = ConflictError

type CreateCompanyResponse = Company

type SearchItem struct {
	ID          string  `json:"id" validate:"required"`
	Title       string  `json:"title" validate:"required"`
	Description *string `json:"description,omitempty"`
}

func (s SearchItem) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(s))
}

type User struct {
	ID    string `json:"id" validate:"required"`
	Name  string `json:"name" validate:"required"`
	Email string `json:"email" validate:"required"`
}

func (u User) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(u))
}

type CreateUserRequest struct {
	Name  string `json:"name" validate:"required"`
	Email string `json:"email" validate:"required"`
}

func (c CreateUserRequest) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type ImportResult struct {
	Imported *int     `json:"imported,omitempty"`
	Skipped  *int     `json:"skipped,omitempty"`
	Errors   []string `json:"errors,omitempty"`
}

type Error struct {
	Code    *string `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

func (s Error) Error() string {
	return "unmapped client error"
}

type TokenResponse struct {
	AccessToken string `json:"access_token" validate:"required"`
	TokenType   string `json:"token_type" validate:"required"`
	ExpiresIn   *int   `json:"expires_in,omitempty"`
}

func (t TokenResponse) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type XMLPayload struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

type Category struct {
	ID          int     `json:"id" validate:"required"`
	Name        string  `json:"name" validate:"required"`
	Description *string `json:"description,omitempty"`
}

func (c Category) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type Product struct {
	ID    string   `json:"id" validate:"required"`
	Name  string   `json:"name" validate:"required"`
	Price float32  `json:"price" validate:"required"`
	Tags  []string `json:"tags,omitempty"`
}

func (p Product) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type Post struct {
	ID        string     `json:"id" validate:"required"`
	UserID    string     `json:"userId" validate:"required"`
	Title     string     `json:"title" validate:"required"`
	Content   string     `json:"content" validate:"required"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
}

func (p Post) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(p))
}

type NotFoundError struct {
	Code    string `json:"code" validate:"required"`
	Message string `json:"message" validate:"required"`

	// Resource The resource type that was not found
	Resource string `json:"resource" validate:"required"`
}

func (n NotFoundError) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(n))
}

func (s NotFoundError) Error() string {
	return "unmapped client error"
}

type ValidationError struct {
	Code    string                 `json:"code" validate:"required"`
	Message string                 `json:"message" validate:"required"`
	Fields  ValidationError_Fields `json:"fields" validate:"required"`
}

func (v ValidationError) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(v.Code, "required"); err != nil {
		errors = errors.Append("Code", err)
	}
	if err := typesValidator.Var(v.Message, "required"); err != nil {
		errors = errors.Append("Message", err)
	}
	if v, ok := any(v.Fields).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Fields", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

func (s ValidationError) Error() string {
	return "unmapped client error"
}

type ValidationError_Fields []ValidationError_Fields_Item

func (v ValidationError_Fields) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range v {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ValidationError_Fields_Item struct {
	Field     *string `json:"field,omitempty"`
	ErrorData *string `json:"error,omitempty"`
}

type ConflictError struct {
	Code    string `json:"code" validate:"required"`
	Message string `json:"message" validate:"required"`

	// ExistingID ID of the conflicting resource
	ExistingID *string `json:"existingId,omitempty"`
}

func (c ConflictError) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type CreateOrderRequest struct {
	ProductID string  `json:"productId" validate:"required"`
	Quantity  int     `json:"quantity" validate:"required,gte=1"`
	Notes     *string `json:"notes,omitempty"`
}

func (c CreateOrderRequest) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type Order struct {
	ID        string      `json:"id" validate:"required"`
	ProductID string      `json:"productId" validate:"required"`
	Quantity  int         `json:"quantity" validate:"required"`
	Status    OrderStatus `json:"status" validate:"required"`
	CreatedAt *time.Time  `json:"createdAt,omitempty"`
}

func (o Order) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(o.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(o.ProductID, "required"); err != nil {
		errors = errors.Append("ProductID", err)
	}
	if err := typesValidator.Var(o.Quantity, "required"); err != nil {
		errors = errors.Append("Quantity", err)
	}
	if v, ok := any(o.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Address struct {
	Street     string  `json:"street" validate:"required"`
	City       string  `json:"city" validate:"required"`
	State      *string `json:"state,omitempty"`
	PostalCode *string `json:"postalCode,omitempty"`
	Country    string  `json:"country" validate:"required"`
}

func (a Address) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(a))
}

type CreateCompanyRequest struct {
	Name     string                         `json:"name" validate:"required"`
	Address  Address                        `json:"address"`
	Contacts *CreateCompanyRequest_Contacts `json:"contacts,omitempty"`
}

func (c CreateCompanyRequest) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(c.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(c.Address).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Address", err)
		}
	}
	if c.Contacts != nil {
		if v, ok := any(c.Contacts).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Contacts", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type CreateCompanyRequest_Contacts []CreateCompanyRequest_Contacts_Item

type CreateCompanyRequest_Contacts_Item struct {
	Name  *string `json:"name,omitempty"`
	Email *string `json:"email,omitempty"`
	Phone *string `json:"phone,omitempty"`
}

type Company struct {
	ID        string            `json:"id" validate:"required"`
	Name      string            `json:"name" validate:"required"`
	Address   Address           `json:"address"`
	Contacts  *Company_Contacts `json:"contacts,omitempty"`
	CreatedAt *time.Time        `json:"createdAt,omitempty"`
}

func (c Company) Validate() error {
	var errors runtime.ValidationErrors
	if err := typesValidator.Var(c.ID, "required"); err != nil {
		errors = errors.Append("ID", err)
	}
	if err := typesValidator.Var(c.Name, "required"); err != nil {
		errors = errors.Append("Name", err)
	}
	if v, ok := any(c.Address).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Address", err)
		}
	}
	if c.Contacts != nil {
		if v, ok := any(c.Contacts).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Contacts", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Company_Contacts []Company_Contacts_Item

type Company_Contacts_Item struct {
	Name  *string `json:"name,omitempty"`
	Email *string `json:"email,omitempty"`
	Phone *string `json:"phone,omitempty"`
}

type Search_Response_OneOf struct {
	runtime.Either[User, SearchItem]
}

func (s *Search_Response_OneOf) Validate() error {
	if s.IsA() {
		if v, ok := any(s.A).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	if s.IsB() {
		if v, ok := any(s.B).(runtime.Validator); ok {
			return v.Validate()
		}
	}
	return nil
}

var typesValidator *validator.Validate

func init() {
	typesValidator = validator.New(validator.WithRequiredStructEnabled())
	runtime.RegisterCustomTypeFunc(typesValidator)
}
