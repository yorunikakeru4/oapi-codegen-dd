// Code generated by oapi-codegen. DO NOT EDIT.

package expression

import (
	"fmt"

	"github.com/yorunikakeru4/oapi-codegen-dd/v3/pkg/runtime"
	"github.com/go-playground/validator/v10"
)

type ApplyFilterBody = FilterRequest

type ApplyFilterResponse struct {
	Result *string `json:"result,omitempty"`
}

type FilterRequest struct {
	Filter *Expression `json:"filter,omitempty"`
}

func (f FilterRequest) Validate() error {
	var errors runtime.ValidationErrors
	if f.Filter != nil {
		if v, ok := any(f.Filter).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Filter", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Expression struct {
	Or         Expressions      `json:"Or,omitempty"`
	And        Expressions      `json:"And,omitempty"`
	Not        *Expression      `json:"Not,omitempty"`
	Dimensions *DimensionValues `json:"Dimensions,omitempty"`
}

func (e Expression) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(e.Or).(runtime.Validator); ok && v != nil {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Or", err)
		}
	}
	if v, ok := any(e.And).(runtime.Validator); ok && v != nil {
		if err := v.Validate(); err != nil {
			errors = errors.Append("And", err)
		}
	}
	if e.Not != nil {
		if v, ok := any(e.Not).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Not", err)
			}
		}
	}
	if e.Dimensions != nil {
		if v, ok := any(e.Dimensions).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Dimensions", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Expressions []Expression

func (e Expressions) Validate() error {
	if e == nil {
		return nil
	}
	var errors runtime.ValidationErrors
	if len(e) < 1 {
		errors = errors.Add("Array", fmt.Sprintf("must have at least 1 items, got %d", len(e)))
	}
	for i, item := range e {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type DimensionValues struct {
	Key    *string  `json:"Key,omitempty"`
	Values []string `json:"Values,omitempty"`
}

var typesValidator *validator.Validate

func init() {
	typesValidator = validator.New(validator.WithRequiredStructEnabled())
	runtime.RegisterCustomTypeFunc(typesValidator)
}
