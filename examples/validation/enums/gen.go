// Code generated by oapi-codegen. DO NOT EDIT.

package gen

import (
	"fmt"

	"github.com/yorunikakeru4/oapi-codegen-dd/v3/pkg/runtime"
	"github.com/go-playground/validator/v10"
)

type Status string

const (
	ACTIVE   Status = "ACTIVE"
	INACTIVE Status = "INACTIVE"
	PENDING  Status = "PENDING"
)

// Validate checks if the Status value is valid
func (s Status) Validate() error {
	switch s {
	case ACTIVE, INACTIVE, PENDING:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid Status value, got: %v", s))
	}
}

// IndicatorUnit A numeric unit for an indicator - includes empty string
type IndicatorUnit string

const (
	Empty     IndicatorUnit = ""
	EuroSign  IndicatorUnit = "€"
	Percent   IndicatorUnit = "%"
	PoundSign IndicatorUnit = "£"
	Pp        IndicatorUnit = "pp"
	Value     IndicatorUnit = "€€"
)

// Validate checks if the IndicatorUnit value is valid
func (i IndicatorUnit) Validate() error {
	switch i {
	case Empty, EuroSign, Percent, PoundSign, Pp, Value:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid IndicatorUnit value, got: %v", i))
	}
}

type NullableStatus string

const (
	NullableStatusACTIVE   NullableStatus = "ACTIVE"
	NullableStatusINACTIVE NullableStatus = "INACTIVE"
)

// Validate checks if the NullableStatus value is valid
func (n NullableStatus) Validate() error {
	switch n {
	case NullableStatusACTIVE, NullableStatusINACTIVE:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid NullableStatus value, got: %v", n))
	}
}

type Response struct {
	Status Status `json:"status" validate:"required"`

	// Unit A numeric unit for an indicator - includes empty string
	Unit           IndicatorUnit   `json:"unit" validate:"required"`
	NullableStatus *NullableStatus `json:"nullableStatus,omitempty"`
}

func (r Response) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(r.Status).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Status", err)
		}
	}
	if v, ok := any(r.Unit).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Unit", err)
		}
	}
	if r.NullableStatus != nil {
		if v, ok := any(r.NullableStatus).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("NullableStatus", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

var typesValidator *validator.Validate

func init() {
	typesValidator = validator.New(validator.WithRequiredStructEnabled())
	runtime.RegisterCustomTypeFunc(typesValidator)
}
