// Code generated by oapi-codegen. DO NOT EDIT.

package full

import (
	"fmt"
	"time"

	"github.com/yorunikakeru4/oapi-codegen-dd/v3/pkg/runtime"
	"github.com/go-playground/validator/v10"
)

type StatusQuery string

const (
	Active  StatusQuery = "active"
	Pending StatusQuery = "pending"
)

// Validate checks if the StatusQuery value is valid
func (s StatusQuery) Validate() error {
	switch s {
	case Active, Pending:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid StatusQuery value, got: %v", s))
	}
}

type Category string

const (
	Clothing    Category = "clothing"
	Electronics Category = "electronics"
	Food        Category = "food"
)

// Validate checks if the Category value is valid
func (c Category) Validate() error {
	switch c {
	case Clothing, Electronics, Food:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid Category value, got: %v", c))
	}
}

type Status string

const (
	Archived  Status = "archived"
	Draft     Status = "draft"
	Published Status = "published"
)

// Validate checks if the Status value is valid
func (s Status) Validate() error {
	switch s {
	case Archived, Draft, Published:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid Status value, got: %v", s))
	}
}

type ItemType string

const (
	ItemTypeCategory ItemType = "category"
	ItemTypeItem     ItemType = "item"
	ItemTypeLabel    ItemType = "label"
)

// Validate checks if the ItemType value is valid
func (i ItemType) Validate() error {
	switch i {
	case ItemTypeCategory, ItemTypeItem, ItemTypeLabel:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid ItemType value, got: %v", i))
	}
}

type ProductType string

const (
	Digital  ProductType = "digital"
	Physical ProductType = "physical"
	Service  ProductType = "service"
)

// Validate checks if the ProductType value is valid
func (p ProductType) Validate() error {
	switch p {
	case Digital, Physical, Service:
		return nil
	default:
		return runtime.NewValidationErrorsFromString("Enum", fmt.Sprintf("must be a valid ProductType value, got: %v", p))
	}
}

type TokenBody struct {
	// Token The token value
	Token string `json:"token" validate:"required"`
}

func (t TokenBody) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(t))
}

type CreateItemBody = Item

type CreateTokenBody struct {
	// Token The token value
	Token string `json:"token" validate:"required"`
}

func (c CreateTokenBody) Validate() error {
	return runtime.ConvertValidatorError(typesValidator.Struct(c))
}

type CreateLabelBody = Label

type ItemQuery = []string

type LabelQuery = []string

type GetItemsQuery struct {
	// Item Filter by item IDs
	Item ItemQuery `json:"item,omitempty"`
}

func (g GetItemsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Item).(runtime.Validator); ok && v != nil {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Item", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetLabelsQuery struct {
	// Label Filter by labels
	Label LabelQuery `json:"label,omitempty"`
}

func (g GetLabelsQuery) Validate() error {
	var errors runtime.ValidationErrors
	if v, ok := any(g.Label).(runtime.Validator); ok && v != nil {
		if err := v.Validate(); err != nil {
			errors = errors.Append("Label", err)
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type GetStatusQuery struct {
	// Status Filter by status
	Status *StatusQuery `json:"status,omitempty"`
}

type LabelList struct {
	Labels []Label `json:"labels,omitempty"`
	Total  *int    `json:"total,omitempty"`
}

type TokenResponse struct {
	// Token Authentication token
	Token     *Token     `json:"token,omitempty"`
	ExpiresAt *time.Time `json:"expires_at,omitempty"`
}

type GetItemsResponse = Item

type GetItemsErrorResponse = Error

type CreateItemResponse = Item

type CreateTokenResponse = TokenResponse

type GetLabelsResponse = LabelList

type CreateLabelResponse = Label

type GetStatusResponse = Status

type Item struct {
	ID       *string   `json:"id,omitempty"`
	Name     *string   `json:"name,omitempty"`
	Category *Category `json:"category,omitempty"`
}

func (i Item) Validate() error {
	var errors runtime.ValidationErrors
	if i.Category != nil {
		if v, ok := any(i.Category).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Category", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Label struct {
	ID    *string `json:"id,omitempty"`
	Name  *string `json:"name,omitempty"`
	Color *string `json:"color,omitempty"`
}

// Token Authentication token
type Token = string

type Product struct {
	Name *string      `json:"name,omitempty"`
	Type *ProductType `json:"type,omitempty"`
}

func (p Product) Validate() error {
	var errors runtime.ValidationErrors
	if p.Type != nil {
		if v, ok := any(p.Type).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append("Type", err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type ItemList struct {
	Items []Item `json:"items,omitempty"`
	Total *int   `json:"total,omitempty"`
}

func (i ItemList) Validate() error {
	var errors runtime.ValidationErrors
	for i, item := range i.Items {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				errors = errors.Append(fmt.Sprintf("Items[%d]", i), err)
			}
		}
	}
	if len(errors) == 0 {
		return nil
	}
	return errors
}

type Error struct {
	Code    *int    `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

func (s Error) Error() string {
	return "unmapped client error"
}

var typesValidator *validator.Validate

func init() {
	typesValidator = validator.New(validator.WithRequiredStructEnabled())
	runtime.RegisterCustomTypeFunc(typesValidator)
}
