// Code generated by oapi-codegen. DO NOT EDIT.

package gen

import (
	"context"
	"encoding/json"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
)

// MCPToolsOption configures the MCPTools.
type MCPToolsOption func(*MCPTools)

// MCPTools registers API operations as MCP tools.
// It uses an HTTP client to make API calls.
//
// TODO: Add MCPAdapter support for direct service calls (similar to HTTPAdapter)
// that would allow calling ServiceInterface directly without HTTP overhead,
// including proper request validation.
type MCPTools struct {
	server *server.MCPServer
	client ClientInterface
}

// NewMCPTools creates a new MCPTools and registers all tools with the MCP server.
func NewMCPTools(s *server.MCPServer, opts ...MCPToolsOption) *MCPTools {
	t := &MCPTools{server: s}
	for _, opt := range opts {
		opt(t)
	}
	t.registerAll()
	return t
}

// WithClient configures MCPTools to use an HTTP client for API calls.
func WithClient(client ClientInterface) MCPToolsOption {
	return func(t *MCPTools) {
		t.client = client
	}
}

func (t *MCPTools) registerAll() {
	t.registerHealthCheck()
	t.registerListUsers()
	t.registerCreateUser()
	t.registerGetUser()
}

func (t *MCPTools) registerHealthCheck() {
	tool := mcp.NewTool("HealthCheck",
		mcp.WithDescription("Health check endpoint"),
	)
	t.server.AddTool(tool, t.handleHealthCheck)
}

func (t *MCPTools) handleHealthCheck(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	result, err := t.client.HealthCheck(ctx)
	if err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}
	return mcp.NewToolResultJSON(result)
}

func (t *MCPTools) registerListUsers() {
	tool := mcp.NewTool("list_users",
		mcp.WithDescription("Retrieve a list of all users in the system"),
		mcp.WithNumber("limit"),
	)
	t.server.AddTool(tool, t.handleListUsers)
}

func (t *MCPTools) handleListUsers(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	opts := &ListUsersRequestOptions{}
	opts.Query = &ListUsersQuery{}
	if v := req.GetInt("limit", 0); v != 0 {
		opts.Query.Limit = &v
	}

	result, err := t.client.ListUsers(ctx, opts)
	if err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}
	return mcp.NewToolResultJSON(result)
}

func (t *MCPTools) registerCreateUser() {
	tool := mcp.NewTool("CreateUser",
		mcp.WithDescription("Create a new user"),
		mcp.WithObject("body", mcp.Description("Request body")),
	)
	t.server.AddTool(tool, t.handleCreateUser)
}

func (t *MCPTools) handleCreateUser(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	opts := &CreateUserRequestOptions{}
	if args := req.GetArguments(); args != nil {
		if bodyData, ok := args["body"]; ok {
			bodyBytes, _ := json.Marshal(bodyData)
			var body CreateUserRequest
			if err := json.Unmarshal(bodyBytes, &body); err == nil {
				opts.Body = &body
			}
		}
	}
	result, err := t.client.CreateUser(ctx, opts)
	if err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}
	return mcp.NewToolResultJSON(result)
}

func (t *MCPTools) registerGetUser() {
	tool := mcp.NewTool("GetUser",
		mcp.WithDescription("Get a user by ID"),
		mcp.WithString("id", mcp.Required()),
	)
	t.server.AddTool(tool, t.handleGetUser)
}

func (t *MCPTools) handleGetUser(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	opts := &GetUserRequestOptions{}
	opts.PathParams = &GetUserPath{}

	opts.PathParams.ID = req.GetString("id", "")

	result, err := t.client.GetUser(ctx, opts)
	if err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}
	return mcp.NewToolResultJSON(result)
}
