package codegen

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/pb33f/libopenapi/datamodel/high/base"
)

// EnumDefinition holds type information for enum
// Schema is the scheme of a type which has a list of enum values, eg, the
// "container" of the enum.
// Name is the name of the enum's type, usually aliased from something.
// ValueWrapper wraps the value. It's used to conditionally apply quotes
// around strings.
// PrefixTypeName determines if the enum value is prefixed with its TypeName.
type EnumDefinition struct {
	Name           string
	ValueWrapper   string
	PrefixTypeName bool
	Schema         GoSchema
}

// GetValues generates enum names in a way to minimize global conflicts
func (e *EnumDefinition) GetValues() map[string]string {
	// in case there are no conflicts, it's safe to use the values as-is
	if !e.PrefixTypeName {
		return e.Schema.EnumValues
	}

	// If we do have conflicts, we will prefix the enum's typename to the values.
	newValues := make(map[string]string, len(e.Schema.EnumValues))
	for k, v := range e.Schema.EnumValues {
		newName := e.Name + UppercaseFirstCharacter(k)
		newValues[newName] = v
	}
	return newValues
}

func createEnumsSchema(schema *base.Schema, ref string, path []string, options ParseOptions) (GoSchema, error) {
	outSchema, err := oapiSchemaToGoType(schema, ref, path, options)
	if err != nil {
		return GoSchema{}, fmt.Errorf("error resolving primitive type: %w", err)
	}

	// Enums need to be typed, so that the values aren't interchangeable,
	// so no matter what schema conversion thinks, we need to define a
	// new type.
	outSchema.DefineViaAlias = false

	enumValues := make([]string, len(schema.Enum))
	for i, enumNode := range schema.Enum {
		enumValues[i] = enumNode.Value
	}

	enumNames := enumValues
	exts := extractExtensions(schema.Extensions)
	for _, key := range []string{extEnumNames} {
		if extension, ok := exts[key]; ok {
			names, err := extParseEnumVarNames(extension)
			if err != nil {
				return outSchema, fmt.Errorf("invalid value for %q: %w", key, err)
			}
			enumNames = names
		}
	}

	sanitizedValues := sanitizeEnumNames(enumNames, enumValues)
	outSchema.EnumValues = make(map[string]string, len(sanitizedValues))

	for k, v := range sanitizedValues {
		outSchema.EnumValues[schemaNameToTypeName(k)] = v
	}

	if len(path) == 0 {
		return outSchema, nil
	}

	if len(path) > 1 {
		// handle additional type only on non-toplevel types
		// Allow overriding autogenerated enum type names, since these may
		// cause conflicts - see https://github.com/oapi-codegen/oapi-codegen/issues/832
		var typeName string
		if extension, ok := exts[extGoTypeName]; ok {
			typeName, err = parseString(extension)
			if err != nil {
				return outSchema, fmt.Errorf("invalid value for %q: %w", extGoTypeName, err)
			}
		} else {
			typeName = schemaNameToTypeName(pathToTypeName(path))
		}

		typeDef := TypeDefinition{
			Name:     typeName,
			JsonName: strings.Join(path, "."),
			Schema:   outSchema,
		}
		outSchema.AdditionalTypes = append(outSchema.AdditionalTypes, typeDef)
		outSchema.RefType = typeName
	}

	return outSchema, nil
}

// sanitizeEnumNames fixes illegal chars in the enum names
// and removes duplicates
func sanitizeEnumNames(enumNames, enumValues []string) map[string]string {
	dupCheck := make(map[string]int, len(enumValues))
	deDup := make([][]string, 0, len(enumValues))

	for i, v := range enumValues {
		n := v
		if i < len(enumNames) {
			n = enumNames[i]
		}
		if _, dup := dupCheck[n]; !dup {
			deDup = append(deDup, []string{n, v})
		}
		dupCheck[n] = 0
	}

	dupCheck = make(map[string]int, len(deDup))
	sanitizedDeDup := make(map[string]string, len(deDup))

	for _, p := range deDup {
		n, v := p[0], p[1]
		sanitized := sanitizeGoIdentity(schemaNameToTypeName(n))

		if _, dup := dupCheck[sanitized]; !dup {
			sanitizedDeDup[sanitized] = v
		} else {
			sanitizedDeDup[sanitized+strconv.Itoa(dupCheck[sanitized])] = v
		}
		dupCheck[sanitized]++
	}

	return sanitizedDeDup
}

func filterOutEnums(types []TypeDefinition, options ParseOptions) ([]EnumDefinition, []TypeDefinition, TypeRegistry) {
	var enums []EnumDefinition
	var rest []TypeDefinition

	// Keep track of which enums we've generated
	m := map[string]int{}

	// These are all types defined globally
	for _, td := range types {
		if cnt := m[td.Name]; cnt > 0 {
			continue
		}

		for _, p := range td.Schema.Properties {
			if len(p.Schema.EnumValues) == 0 {
				continue
			}

			name := p.Schema.RefType
			if name == "" {
				name = p.GoName
			}

			if cnt := m[name]; cnt > 0 {
				continue
			}

			wrapper := ""
			if p.Schema.GoType == "string" {
				wrapper = `"`
			}

			enums = append(enums, EnumDefinition{
				Schema:         p.Schema,
				Name:           name,
				ValueWrapper:   wrapper,
				PrefixTypeName: options.AlwaysPrefixEnumValues,
			})
			m[name] = 1
		}

		if len(td.Schema.EnumValues) > 0 {
			wrapper := ""
			if td.Schema.GoType == "string" {
				wrapper = `"`
			}
			enums = append(enums, EnumDefinition{
				Schema:         td.Schema,
				Name:           td.Name,
				ValueWrapper:   wrapper,
				PrefixTypeName: options.AlwaysPrefixEnumValues,
			})
		} else {
			rest = append(rest, td)
		}
		m[td.Name] = 1
	}

	// Now, go through all the enums, and figure out if we have conflicts with any others.
	for i := range enums {
		// Look through all other enums not compared so far.
		// Make sure we don't compare against self.
		e1 := enums[i]
		for j := i + 1; j < len(enums); j++ {
			e2 := enums[j]

			for e1key := range e1.GetValues() {
				_, found := e2.GetValues()[e1key]
				if found {
					e1.PrefixTypeName = true
					e2.PrefixTypeName = true
					enums[i] = e1
					enums[j] = e2
					break
				}
			}
		}

		// now see if this enum conflicts with any type names.
		for _, tp := range types {
			// Skip over enums, since we've handled those above.
			if len(tp.Schema.EnumValues) > 0 {
				continue
			}
			_, found := e1.Schema.EnumValues[tp.Name]
			if found {
				e1.PrefixTypeName = true
				enums[i] = e1
			}
		}

		_, found := e1.GetValues()[e1.Name]
		if found {
			e1.PrefixTypeName = true
			enums[i] = e1
		}
	}

	return enums, rest, m
}
