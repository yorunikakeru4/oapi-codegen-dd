package codegen

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

// EnumDefinition holds type information for enum
type EnumDefinition struct {
	// Schema is the scheme of a type which has a list of enum values, eg, the
	// "container" of the enum.
	Schema Schema
	// TypeName is the name of the enum's type, usually aliased from something.
	TypeName string
	// ValueWrapper wraps the value. It's used to conditionally apply quotes
	// around strings.
	ValueWrapper string
	// PrefixTypeName determines if the enum value is prefixed with its TypeName.
	// This is set to true when this enum conflicts with another in terms of
	// TypeNames or when explicitly requested via the
	// `compatibility.always-prefix-enum-values` option.
	PrefixTypeName bool
}

// GetValues generates enum names in a way to minimize global conflicts
func (e *EnumDefinition) GetValues() map[string]string {
	// in case there are no conflicts, it's safe to use the values as-is
	if !e.PrefixTypeName {
		return e.Schema.EnumValues
	}
	// If we do have conflicts, we will prefix the enum's typename to the values.
	newValues := make(map[string]string, len(e.Schema.EnumValues))
	for k, v := range e.Schema.EnumValues {
		newName := e.TypeName + UppercaseFirstCharacter(k)
		newValues[newName] = v
	}
	return newValues
}

func createEnumsSchema(schema *openapi3.Schema, path []string) (Schema, error) {
	outSchema, err := oapiSchemaToGoType(schema, path)
	if err != nil {
		return Schema{}, nil
	}

	// Enums need to be typed, so that the values aren't interchangeable,
	// so no matter what schema conversion thinks, we need to define a
	// new type.
	outSchema.DefineViaAlias = false

	if err != nil {
		return Schema{}, fmt.Errorf("error resolving primitive type: %w", err)
	}
	enumValues := make([]string, len(schema.Enum))
	for i, enumValue := range schema.Enum {
		enumValues[i] = fmt.Sprintf("%v", enumValue)
	}

	enumNames := enumValues
	for _, key := range []string{extEnumVarNames, extEnumNames} {
		if extension, ok := schema.Extensions[key]; ok {
			if extEnumNames, err := extParseEnumVarNames(extension); err == nil {
				enumNames = extEnumNames
				break
			}
		}
	}

	sanitizedValues := SanitizeEnumNames(enumNames, enumValues)
	outSchema.EnumValues = make(map[string]string, len(sanitizedValues))

	for k, v := range sanitizedValues {
		outSchema.EnumValues[SchemaNameToTypeName(k)] = v
	}

	if len(path) > 1 { // handle additional type only on non-toplevel types
		// Allow overriding autogenerated enum type names, since these may
		// cause conflicts - see https://github.com/oapi-codegen/oapi-codegen/issues/832
		var typeName string
		if extension, ok := schema.Extensions[extGoTypeName]; ok {
			typeName, err = extString(extension)
			if err != nil {
				return outSchema, fmt.Errorf("invalid value for %q: %w", extGoTypeName, err)
			}
		} else {
			typeName = SchemaNameToTypeName(PathToTypeName(path))
		}

		typeDef := TypeDefinition{
			TypeName: typeName,
			JsonName: strings.Join(path, "."),
			Schema:   outSchema,
		}
		outSchema.AdditionalTypes = append(outSchema.AdditionalTypes, typeDef)
		outSchema.RefType = typeName
	}

	return outSchema, nil
}

// SanitizeEnumNames fixes illegal chars in the enum names
// and removes duplicates
func SanitizeEnumNames(enumNames, enumValues []string) map[string]string {
	dupCheck := make(map[string]int, len(enumValues))
	deDup := make([][]string, 0, len(enumValues))

	for i, v := range enumValues {
		n := v
		if i < len(enumNames) {
			n = enumNames[i]
		}
		if _, dup := dupCheck[n]; !dup {
			deDup = append(deDup, []string{n, v})
		}
		dupCheck[n] = 0
	}

	dupCheck = make(map[string]int, len(deDup))
	sanitizedDeDup := make(map[string]string, len(deDup))

	for _, p := range deDup {
		n, v := p[0], p[1]
		sanitized := SanitizeGoIdentity(SchemaNameToTypeName(n))

		if _, dup := dupCheck[sanitized]; !dup {
			sanitizedDeDup[sanitized] = v
		} else {
			sanitizedDeDup[sanitized+strconv.Itoa(dupCheck[sanitized])] = v
		}
		dupCheck[sanitized]++
	}

	return sanitizedDeDup
}
