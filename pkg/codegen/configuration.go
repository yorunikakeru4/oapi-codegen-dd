package codegen

const (
	// TODO: check if needed
	disableTypeAliasesForArray = true
)

// Configuration defines code generation customizations.
// PackageName to generate the code under.
// CopyrightHeader is the header to add to the generated code. Use without //.
// SkipPrune indicates whether to skip pruning unused components on the generated code.
// Output specifies the output options for the generated code.
//
// Filter is the configuration for filtering the paths and operations to be parsed.
//
// AdditionalImports defines any additional Go imports to add to the generated code.
// ErrorMapping is the configuration for mapping the OpenAPI error responses to Go types.
//
//	The key is the spec error type name
//	and the value is the dotted json path to the string result.
//
// UserTemplates is the map of user-provided templates overriding the default ones.
// UserContext is the map of user-provided context values to be used in templates user overrides.
type Configuration struct {
	PackageName     string  `yaml:"package"`
	CopyrightHeader string  `yaml:"copyright-header"`
	SkipPrune       bool    `yaml:"skip-prune"`
	Output          *Output `yaml:"output"`

	Generate *GenerateOptions `yaml:"generate"`
	Filter   FilterConfig     `yaml:"filter,omitempty"`

	AdditionalImports []AdditionalImport `yaml:"additional-imports,omitempty"`
	ErrorMapping      map[string]string  `yaml:"error-mapping,omitempty"`
	NameMapping       map[string]string  `yaml:"name-mapping,omitempty"`

	UserTemplates map[string]string `yaml:"user-templates,omitempty"`
	UserContext   map[string]any    `yaml:"user-context,omitempty"`
}

func (o Configuration) Merge(other Configuration) Configuration {
	if o.PackageName == "" && other.PackageName != "" {
		o.PackageName = other.PackageName
	}
	if o.CopyrightHeader == "" && other.CopyrightHeader != "" {
		o.CopyrightHeader = other.CopyrightHeader
	}

	if o.Output != nil {
		if o.Output.Directory == "" {
			o.Output.Directory = "."
		}
		if o.Output.UseSingleFile && o.Output.Filename == "" {
			o.Output.Filename = "gen.go"
		}
	}

	if o.Generate == nil {
		o.Generate = other.Generate
		if o.Generate == nil {
			o.Generate = &GenerateOptions{
				Client: true,
			}
		}
	}

	if o.NameMapping == nil {
		o.NameMapping = other.NameMapping
	}

	return o
}

type AdditionalImport struct {
	Alias   string `yaml:"alias,omitempty"`
	Package string `yaml:"package"`
}

// FilterConfig is the configuration for filtering the paths and operations to be parsed.
type FilterConfig struct {
	Include FilterParamsConfig `yaml:"include"`
	Exclude FilterParamsConfig `yaml:"exclude"`
}

// FilterParamsConfig is the configuration for filtering the paths to be parsed.
type FilterParamsConfig struct {
	Paths            []string            `yaml:"paths"`
	Tags             []string            `yaml:"tags"`
	OperationIDs     []string            `yaml:"operation-ids"`
	SchemaProperties map[string][]string `yaml:"schema-properties"`
}

type GenerateOptions struct {
	// Client specifies whether to generate a client. Defaults to true.
	Client bool `yaml:"client"`

	// OmitDescription specifies whether to omit schema description from the spec in the generated code. Defaults to false.
	OmitDescription bool `yaml:"omit-description"`
}

type Output struct {
	UseSingleFile bool   `yaml:"use-single-file"`
	Directory     string `yaml:"directory"`
	Filename      string `yaml:"filename"`
}

// NewDefaultConfiguration creates a new default Configuration.
func NewDefaultConfiguration() Configuration {
	return Configuration{
		PackageName:     "gen",
		CopyrightHeader: "Code generated by oapi-codegen. DO NOT EDIT.",
		NameMapping: map[string]string{
			"client": "Client",
		},
		Generate: &GenerateOptions{
			Client: true,
		},
	}
}

type keyValue[K, V any] struct {
	key   K
	value V
}
