{{/*
Copyright 2026 DoorDash, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/}}
{{- $config := .Config -}}
{{- $operations := .Operations -}}
{{- $serviceName := $config.Generate.Handler.Name -}}
{{- $validateRequest := $config.Generate.Handler.Validation.Request -}}
{{- $validateResponse := $config.Generate.Handler.Validation.Response -}}
{{- $multipartMaxMemory := $config.Generate.Handler.MultipartMaxMemory -}}
{{- /* Adapter is always generated in the same package as models, so no prefix needed */ -}}
{{- template "handler-header" $ }}

// {{ $serviceName }}Interface defines the service interface for business logic.
type {{ $serviceName }}Interface interface {
{{- range $operations }}{{ $op := . }}
    {{ toGoComment $op.Summary $op.ID }}
    {{- if $op.HasRequestOptions }}
        {{ $op.ID }}(ctx context.Context, opts *{{ $op.ID | ucFirst }}ServiceRequestOptions) ({{ if $op.Response.Success }}*{{ $op.ID | ucFirst }}ResponseData, error{{ else }}error{{ end }})
    {{- else }}
        {{ $op.ID }}(ctx context.Context) ({{ if $op.Response.Success }}*{{ $op.ID | ucFirst }}ResponseData, error{{ else }}error{{ end }})
    {{- end }}
{{- end }}
}

// HTTPAdapter adapts the {{ $serviceName }}Interface to HTTP handlers.
// This struct is generated and should not be modified.
type HTTPAdapter struct {
    svc {{ $serviceName }}Interface
    errHandler OapiErrorHandler
}

// NewHTTPAdapter creates a new HTTPAdapter wrapping the given service.
// If errHandler is nil, OapiDefaultErrorHandler is used.
func NewHTTPAdapter(svc {{ $serviceName }}Interface, errHandler OapiErrorHandler) *HTTPAdapter {
    if errHandler == nil {
        errHandler = &OapiDefaultErrorHandler{}
    }
    return &HTTPAdapter{svc: svc, errHandler: errHandler}
}

{{define "handle-validation-error"}}
{{- $op := .Op -}}
{{- $config := .Config -}}
{{- /* Determine error type name: use underlying type for aliases, response name otherwise */ -}}
{{- $errorTypeName := "" -}}
{{- if $op.Response.Error -}}
    {{- if $op.Response.Error.Schema.DefineViaAlias -}}
        {{- $errorTypeName = $op.Response.Error.Schema.GoType -}}
    {{- else -}}
        {{- $errorTypeName = $op.Response.Error.ResponseName -}}
    {{- end -}}
{{- end -}}
{{- $hasTypedError := and $errorTypeName (index $config.ErrorMapping $errorTypeName) -}}
    // Validate request
    if err := opts.Validate(); err != nil {
        {{- if $hasTypedError }}
        a.errHandler.HandleError(w, r, {{ $op.Response.Error.StatusCode }}, New{{ $errorTypeName }}(err.Error()))
        {{- else }}
        a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
            Kind:        OapiErrorKindValidation,
            OperationID: "{{ $op.ID }}",
            Message:     err.Error(),
        })
        {{- end }}
        return
    }
{{end}}

{{define "handle-service-error"}}
{{- $op := .Op -}}
if err != nil {
    code := http.StatusInternalServerError
    {{- if $op.Response.Error }}
        {{- if not (or $op.Response.Error.Schema.DefineViaAlias $op.Response.Error.Schema.IsAnyType) }}
            if _, ok := err.(*{{ $op.Response.Error.ResponseName }}); ok {
                code = {{ $op.Response.Error.StatusCode }}
            }
        {{- end }}
    {{- end }}
    a.errHandler.HandleError(w, r, code, err)
    return
}
{{end}}

{{ range $operations }}{{ $op := . }}
{{- /* Determine error type name: use underlying type for aliases, response name otherwise */ -}}
{{- $errorTypeName := "" -}}
{{- if $op.Response.Error -}}
    {{- if $op.Response.Error.Schema.DefineViaAlias -}}
        {{- $errorTypeName = $op.Response.Error.Schema.GoType -}}
    {{- else -}}
        {{- $errorTypeName = $op.Response.Error.ResponseName -}}
    {{- end -}}
{{- end -}}
{{- $hasTypedError := and $errorTypeName (index $config.ErrorMapping $errorTypeName) -}}
// {{ $op.ID | ucFirst }} handles {{ $op.Method }} {{ $op.Path }}
func (a *HTTPAdapter) {{ $op.ID | ucFirst }}(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
{{- if $op.HasRequestOptions }}
    opts := &{{ $op.ID | ucFirst }}ServiceRequestOptions{}
    opts.RawRequest = r
{{- end }}

{{ if $op.PathParams }}
    // Parse path parameters
    pathParams := &{{ $op.PathParams.Name }}{}
    {{- range $op.PathParams.Schema.Properties }}
        {{- $paramVar := printf "pathParam%s" .GoName }}
        {{ $paramVar }}Str := {{template "get-path-param" .JsonFieldName}}
        {{- if eq .Schema.TypeDecl "string" }}
            {{- if .IsPointerType }}
        pathParams.{{ .GoName }} = &{{ $paramVar }}Str
            {{- else }}
        pathParams.{{ .GoName }} = {{ $paramVar }}Str
            {{- end }}
        {{- else if and (eq .Schema.GoType "string") (ne .Schema.TypeDecl "string") }}
        {{/* String-based enum type - use type conversion */}}
            {{- if .IsPointerType }}
        {{ $paramVar }} := {{ .Schema.TypeDecl }}({{ $paramVar }}Str)
        pathParams.{{ .GoName }} = &{{ $paramVar }}
            {{- else }}
        pathParams.{{ .GoName }} = {{ .Schema.TypeDecl }}({{ $paramVar }}Str)
            {{- end }}
        {{- else }}
            {{/* Other types (int, uuid.UUID, etc.) - use ParseString with format hint */}}
            {{ $paramVar }}, err := runtime.ParseString[{{ .Schema.TypeDecl }}]({{ $paramVar }}Str{{- if .Schema.Format }}, "{{ escapeGoString .Schema.Format }}"{{- end }})
            if err != nil {
                {{- if $hasTypedError }}
                a.errHandler.HandleError(w, r, {{ $op.Response.Error.StatusCode }}, New{{ $errorTypeName }}(err.Error()))
                {{- else }}
                a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
                    Kind:          OapiErrorKindParse,
                    OperationID:   "{{ $op.ID }}",
                    Message:       err.Error(),
                    ParamName:     "{{ .JsonFieldName }}",
                    ParamLocation: "path",
                })
                {{- end }}
                return
            }
            {{- if .IsPointerType }}
        pathParams.{{ .GoName }} = &{{ $paramVar }}
            {{- else }}
        pathParams.{{ .GoName }} = {{ $paramVar }}
            {{- end }}
        {{- end }}
    {{- end }}
    opts.PathParams = pathParams
{{- end }}
{{- if $op.Query }}
    // Parse query parameters
    queryParams := &{{ $op.Query.Name }}{}
    query := r.URL.Query()
    {{- range $op.Query.Params }}
        {{- $paramVar := printf "queryParam%s" .GoName }}
        {{- if .IsJson }}
            {{/* JSON-encoded query param: parse as JSON */}}
            if {{ $paramVar }}Str := query.Get("{{ escapeGoString .ParamName }}"); {{ $paramVar }}Str != "" {
                var {{ $paramVar }} {{ .Schema.TypeDecl }}
                if err := json.Unmarshal([]byte({{ $paramVar }}Str), &{{ $paramVar }}); err != nil {
                    {{- if $hasTypedError }}
                    a.errHandler.HandleError(w, r, {{ $op.Response.Error.StatusCode }}, New{{ $errorTypeName }}(fmt.Sprintf("invalid JSON for parameter {{ escapeGoString .ParamName }}: %v", err)))
                    {{- else }}
                    a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
                        Kind:        OapiErrorKindDecode,
                        OperationID: "{{ $op.ID }}",
                        Message:     fmt.Sprintf("invalid JSON for parameter {{ escapeGoString .ParamName }}: %v", err),
                    })
                    {{- end }}
                    return
                }
            {{- if .IsPointerType }}
                queryParams.{{ .GoName }} = &{{ $paramVar }}
            {{- else }}
                queryParams.{{ .GoName }} = {{ $paramVar }}
            {{- end }}
            }
        {{- else if .Schema.ArrayType }}
            {{/* Array query params: use query["key"] to get all values */}}
            if values, ok := query["{{ escapeGoString .ParamName }}"]; ok {
                {{- if hasPrefix .Schema.GoType "[]*" }}
                    {{/* Nullable array - parse and convert each element to pointer */}}
                    {{- if eq .Schema.ArrayType.TypeDecl "string" }}
                    result := make([]*string, len(values))
                    for i := range values {
                        result[i] = &values[i]
                    }
                    {{- else }}
                    parsed, err := runtime.ParseStringSlice[{{ .Schema.ArrayType.TypeDecl }}](values{{- if .Schema.ArrayType.Format }}, "{{ escapeGoString .Schema.ArrayType.Format }}"{{- end }})
                    if err != nil {
                        {{- if $hasTypedError }}
                        a.errHandler.HandleError(w, r, {{ $op.Response.Error.StatusCode }}, New{{ $errorTypeName }}(err.Error()))
                        {{- else }}
                        a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
                            Kind:          OapiErrorKindParse,
                            OperationID:   "{{ $op.ID }}",
                            Message:       err.Error(),
                            ParamName:     "{{ escapeGoString .ParamName }}",
                            ParamLocation: "query",
                        })
                        {{- end }}
                        return
                    }
                    result := make({{ .Schema.GoType }}, len(parsed))
                    for i := range parsed {
                        result[i] = &parsed[i]
                    }
                    {{- end }}
                    queryParams.{{ .GoName }} = result
                {{- else if eq .Schema.ArrayType.TypeDecl "string" }}
                    queryParams.{{ .GoName }} = values
                {{- else if and (eq .Schema.ArrayType.GoType "string") (ne .Schema.ArrayType.TypeDecl "string") }}
                    {{/* String-based enum array - convert each element */}}
                    result := make([]{{ .Schema.ArrayType.TypeDecl }}, len(values))
                    for i, v := range values {
                        result[i] = {{ .Schema.ArrayType.TypeDecl }}(v)
                    }
                    queryParams.{{ .GoName }} = result
                {{- else }}
                    parsed, err := runtime.ParseStringSlice[{{ .Schema.ArrayType.TypeDecl }}](values{{- if .Schema.ArrayType.Format }}, "{{ escapeGoString .Schema.ArrayType.Format }}"{{- end }})
                    if err != nil {
                        {{- if $hasTypedError }}
                        a.errHandler.HandleError(w, r, {{ $op.Response.Error.StatusCode }}, New{{ $errorTypeName }}(err.Error()))
                        {{- else }}
                        a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
                            Kind:          OapiErrorKindParse,
                            OperationID:   "{{ $op.ID }}",
                            Message:       err.Error(),
                            ParamName:     "{{ escapeGoString .ParamName }}",
                            ParamLocation: "query",
                        })
                        {{- end }}
                        return
                    }
                    queryParams.{{ .GoName }} = parsed
                {{- end }}
            }
        {{- else }}
            if {{ $paramVar }}Str := query.Get("{{ escapeGoString .ParamName }}"); {{ $paramVar }}Str != "" {
            {{- if eq .Schema.TypeDecl "string" }}
                {{ $paramVar }} := {{ $paramVar }}Str
            {{- else if and (eq .Schema.GoType "string") (ne .Schema.TypeDecl "string") }}
                {{/* String-based enum type - use type conversion */}}
                {{ $paramVar }} := {{ .Schema.TypeDecl }}({{ $paramVar }}Str)
            {{- else }}
                {{ $paramVar }}, err := runtime.ParseString[{{ .Schema.TypeDecl }}]({{ $paramVar }}Str{{- if .Schema.Format }}, "{{ escapeGoString .Schema.Format }}"{{- end }})
                if err != nil {
                    {{- if $hasTypedError }}
                    a.errHandler.HandleError(w, r, {{ $op.Response.Error.StatusCode }}, New{{ $errorTypeName }}(err.Error()))
                    {{- else }}
                    a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
                        Kind:          OapiErrorKindParse,
                        OperationID:   "{{ $op.ID }}",
                        Message:       err.Error(),
                        ParamName:     "{{ escapeGoString .ParamName }}",
                        ParamLocation: "query",
                    })
                    {{- end }}
                    return
                }
            {{- end }}
            {{- if .IsPointerType }}
                queryParams.{{ .GoName }} = &{{ $paramVar }}
            {{- else }}
                queryParams.{{ .GoName }} = {{ $paramVar }}
            {{- end }}
            }
        {{- end }}
    {{- end }}
    opts.Query = queryParams
{{- end }}
{{- if $op.Header }}

    // Parse header parameters
    headerParams := &{{ $op.Header.TypeDef.Name }}{}
    headers := r.Header
    {{- range $op.Header.Params }}
    {{- $paramVar := printf "headerParam%s" .GoName }}
    if headerValues := headers[http.CanonicalHeaderKey("{{ escapeGoString .ParamName }}")]; len(headerValues) > 0 {
        {{- if eq .Schema.TypeDecl "string" }}
            {{ $paramVar }} := headerValues[0]
        {{- else if and (eq .Schema.GoType "string") (ne .Schema.TypeDecl "string") }}
            {{/* String-based enum type - use type conversion */}}
            {{ $paramVar }} := {{ .Schema.TypeDecl }}(headerValues[0])
        {{- else }}
            {{ $paramVar }}, err := runtime.ParseString[{{ .Schema.TypeDecl }}](headerValues[0]{{- if .Schema.Format }}, "{{ escapeGoString .Schema.Format }}"{{- end }})
            if err != nil {
                {{- if $hasTypedError }}
                a.errHandler.HandleError(w, r, {{ $op.Response.Error.StatusCode }}, New{{ $errorTypeName }}(err.Error()))
                {{- else }}
                a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
                    Kind:          OapiErrorKindParse,
                    OperationID:   "{{ $op.ID }}",
                    Message:       err.Error(),
                    ParamName:     "{{ escapeGoString .ParamName }}",
                    ParamLocation: "header",
                })
                {{- end }}
                return
            }
        {{- end }}
        {{- if .IsPointerType }}
            headerParams.{{ .GoName }} = &{{ $paramVar }}
        {{- else }}
            headerParams.{{ .GoName }} = {{ $paramVar }}
        {{- end }}
    }
    {{- end }}
    opts.Header = headerParams
{{- end }}
{{- if $op.Body }}
    // Parse request body
    defer r.Body.Close()
    {{- if or (eq $op.Body.ContentType "application/json") (hasSuffix $op.Body.ContentType "+json") }}
    var body {{ $op.Body.Name }}
    if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
        {{- if $hasTypedError }}
        a.errHandler.HandleError(w, r, {{ $op.Response.Error.StatusCode }}, New{{ $errorTypeName }}(err.Error()))
        {{- else }}
        a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
            Kind:        OapiErrorKindDecode,
            OperationID: "{{ $op.ID }}",
            Message:     err.Error(),
        })
        {{- end }}
        return
    }
    opts.Body = &body
    {{- else if eq $op.Body.ContentType "application/x-www-form-urlencoded" }}
    var body {{ $op.Body.Name }}
    formBytes, err := io.ReadAll(r.Body)
    if err != nil {
        {{- if $hasTypedError }}
        a.errHandler.HandleError(w, r, {{ $op.Response.Error.StatusCode }}, New{{ $errorTypeName }}(err.Error()))
        {{- else }}
        a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
            Kind:        OapiErrorKindDecode,
            OperationID: "{{ $op.ID }}",
            Message:     err.Error(),
        })
        {{- end }}
        return
    }
    jsonBytes, err := runtime.ConvertFormFields(formBytes)
    if err != nil {
        {{- if $hasTypedError }}
        a.errHandler.HandleError(w, r, {{ $op.Response.Error.StatusCode }}, New{{ $errorTypeName }}(err.Error()))
        {{- else }}
        a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
            Kind:        OapiErrorKindDecode,
            OperationID: "{{ $op.ID }}",
            Message:     err.Error(),
        })
        {{- end }}
        return
    }
    if err := json.Unmarshal(jsonBytes, &body); err != nil {
        {{- if $hasTypedError }}
        a.errHandler.HandleError(w, r, {{ $op.Response.Error.StatusCode }}, New{{ $errorTypeName }}(err.Error()))
        {{- else }}
        a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
            Kind:        OapiErrorKindDecode,
            OperationID: "{{ $op.ID }}",
            Message:     err.Error(),
        })
        {{- end }}
        return
    }
    opts.Body = &body
    {{- else if or (eq $op.Body.ContentType "text/plain") (eq $op.Body.ContentType "text/html") }}
        {{- if or (eq $op.Body.Schema.GoType "string") (eq $op.Body.Schema.TypeDecl "string") }}
            bodyBytes, err := io.ReadAll(r.Body)
            if err != nil {
                {{- if $hasTypedError }}
                a.errHandler.HandleError(w, r, {{ $op.Response.Error.StatusCode }}, New{{ $errorTypeName }}(err.Error()))
                {{- else }}
                a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
                    Kind:        OapiErrorKindDecode,
                    OperationID: "{{ $op.ID }}",
                    Message:     err.Error(),
                })
                {{- end }}
                return
            }
            body := {{ $op.Body.Name }}(string(bodyBytes))
            opts.Body = &body
        {{- else }}
        // text/plain body with non-string schema - skip body parsing
        {{- end }}
    {{- else if hasPrefix $op.Body.ContentType "multipart/" }}
        if err := r.ParseMultipartForm({{ $multipartMaxMemory }} << 20); err != nil {
            {{- if $hasTypedError }}
            a.errHandler.HandleError(w, r, {{ $op.Response.Error.StatusCode }}, New{{ $errorTypeName }}(err.Error()))
            {{- else }}
            a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
                Kind:        OapiErrorKindDecode,
                OperationID: "{{ $op.ID }}",
                Message:     err.Error(),
            })
            {{- end }}
            return
        }
        var body {{ $op.Body.Name }}
        {{- range $op.Body.Schema.Properties }}
            {{- if .IsFile }}
                if fileHeaders := r.MultipartForm.File["{{ .JsonFieldName }}"]; len(fileHeaders) > 0 {
                    body.{{ .GoName }}.InitFromMultipart(fileHeaders[0])
                }
            {{- else }}
                if values := r.MultipartForm.Value["{{ .JsonFieldName }}"]; len(values) > 0 {
                    {{- if .Schema.ArrayType }}
                    {{/* Array type - assign all values */}}
                    {{- if eq .Schema.ArrayType.TypeDecl "string" }}
                    body.{{ .GoName }} = values
                    {{- else if and (eq .Schema.ArrayType.GoType "string") (ne .Schema.ArrayType.TypeDecl "string") }}
                    {{/* String-based enum array - convert each element */}}
                    {
                        result := make([]{{ .Schema.ArrayType.TypeDecl }}, len(values))
                        for i, v := range values {
                            result[i] = {{ .Schema.ArrayType.TypeDecl }}(v)
                        }
                        body.{{ .GoName }} = result
                    }
                    {{- else }}
                    body.{{ .GoName }}, _ = runtime.ParseStringSlice[{{ .Schema.ArrayType.TypeDecl }}](values{{- if .Schema.ArrayType.Format }}, "{{ escapeGoString .Schema.ArrayType.Format }}"{{- end }})
                    {{- end }}
                    {{- else if or (hasPrefix .Schema.TypeDecl "map[") .Schema.HasAdditionalProperties }}
                    {{/* Complex type (struct, map) - parse as JSON */}}
                    if err := json.Unmarshal([]byte(values[0]), &body.{{ .GoName }}); err != nil {
                        {{- if $hasTypedError }}
                        a.errHandler.HandleError(w, r, {{ $op.Response.Error.StatusCode }}, New{{ $errorTypeName }}(err.Error()))
                        {{- else }}
                        a.errHandler.HandleError(w, r, http.StatusBadRequest, OapiHandlerError{
                            Kind:        OapiErrorKindDecode,
                            OperationID: "{{ $op.ID }}",
                            Message:     err.Error(),
                        })
                        {{- end }}
                        return
                    }
                    {{- else if eq .Schema.TypeDecl "string" }}
                    {{/* Plain string type */}}
                    {{- if .IsPointerType }}
                    body.{{ .GoName }} = &values[0]
                    {{- else }}
                    body.{{ .GoName }} = values[0]
                    {{- end }}
                    {{- else if and (eq .Schema.GoType "string") (ne .Schema.TypeDecl "string") }}
                    {{/* String-based enum type - use type conversion */}}
                    {{- if .IsPointerType }}
                    { v := {{ .Schema.TypeDecl }}(values[0]); body.{{ .GoName }} = &v }
                    {{- else }}
                    body.{{ .GoName }} = {{ .Schema.TypeDecl }}(values[0])
                    {{- end }}
                    {{- else }}
                    {{/* Primitive types (bool, int, int64, float64, uuid.UUID, etc.) - use ParseString */}}
                    if v, err := runtime.ParseString[{{ .Schema.TypeDecl }}](values[0]{{- if .Schema.Format }}, "{{ escapeGoString .Schema.Format }}"{{- end }}); err == nil {
                        body.{{ .GoName }}{{ if .IsPointerType }} = &v{{ else }} = v{{ end }}
                    }
                    {{- end }}
                }
            {{- end }}
        {{- end }}
    opts.Body = &body
    {{- end }}
{{- end }}

{{- if $validateRequest }}
{{- if $op.HasRequestOptions }}
    {{template "handle-validation-error" (dict "Op" $op "Config" $config)}}
{{- end }}
{{- end }}

// Call business logic
{{- if $op.HasRequestOptions }}
    {{- if $op.Response.Success }}
        resp, err := a.svc.{{ $op.ID }}(ctx, opts)
    {{- else }}
        err := a.svc.{{ $op.ID }}(ctx, opts)
    {{- end }}
{{- else }}
    {{- if $op.Response.Success }}
        resp, err := a.svc.{{ $op.ID }}(ctx)
    {{- else }}
        err := a.svc.{{ $op.ID }}(ctx)
    {{- end }}
{{- end }}
{{template "handle-service-error" (dict "Op" $op)}}

{{- if $op.Response.Success }}
    {{ if $validateResponse }}
        // Validate response
        if resp != nil && resp.Body != nil {
            if v, ok := any(resp.Body).(runtime.Validator); ok {
                if err := v.Validate(); err != nil {
                    a.errHandler.HandleError(w, r, http.StatusInternalServerError, OapiHandlerError{
                        Kind:        OapiErrorKindValidation,
                        OperationID: "{{ $op.ID }}",
                        Message:     fmt.Sprintf("response validation failed: %v", err),
                    })
                    return
                }
            }
        }
    {{- end }}

    // Apply custom headers from response
    if resp != nil && resp.Headers != nil {
        for k, v := range resp.Headers {
            for _, val := range v {
                w.Header().Add(k, val)
            }
        }
    }

    // Determine status code
    status := {{ $op.Response.SuccessStatusCode }}
    if resp != nil && resp.Status != 0 {
        status = resp.Status
    }

    {{- if eq $op.Response.SuccessStatusCode 204 }}
        w.WriteHeader(status)
    {{- else if $op.Response.Success.ContentType }}
        w.Header().Set("Content-Type", "{{ escapeGoString $op.Response.Success.ContentType }}")
    {{- if or (eq $op.Response.Success.ContentType "application/json") (hasPrefix $op.Response.Success.ContentType "application/json;") (hasSuffix $op.Response.Success.ContentType "+json") (contains $op.Response.Success.ContentType "+json;") }}
        w.WriteHeader(status)
        if resp != nil && resp.Body != nil {
            _ = json.NewEncoder(w).Encode(resp.Body)
        }
    {{- else if or (eq $op.Response.Success.ContentType "text/plain") (hasPrefix $op.Response.Success.ContentType "text/plain;") (eq $op.Response.Success.ContentType "text/html") (hasPrefix $op.Response.Success.ContentType "text/html;") }}
        w.WriteHeader(status)
        if resp != nil && resp.Body != nil {
            _, _ = fmt.Fprintf(w, "%v", *resp.Body)
        }
    {{- else if or (eq $op.Response.Success.ContentType "application/octet-stream") (hasPrefix $op.Response.Success.ContentType "application/octet-stream;") }}
        w.WriteHeader(status)
        if resp != nil && resp.Body != nil {
            {{- if or (eq $op.Response.Success.Schema.GoType "runtime.File") (eq $op.Response.Success.Schema.Format "binary") }}
            data, err := resp.Body.Bytes()
            if err != nil {
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
            }
            _, _ = w.Write(data)
            {{- else if eq $op.Response.Success.Schema.GoType "[]byte" }}
            _, _ = w.Write(resp.Body)
            {{- else if eq $op.Response.Success.Schema.GoType "string" }}
            _, _ = w.Write([]byte(*resp.Body))
            {{- else }}
            // NOTE: application/octet-stream with struct schema - this may be a spec issue.
            // octet-stream typically expects binary data, falling back to JSON encoding.
            _ = json.NewEncoder(w).Encode(resp.Body)
            {{- end }}
        }
    {{- else if eq $op.Response.Success.ContentType "application/x-www-form-urlencoded" }}
        w.WriteHeader(status)
        if resp != nil && resp.Body != nil {
            formData, err := runtime.EncodeFormFields(resp.Body, nil)
            if err == nil {
                _, _ = w.Write([]byte(formData))
            }
        }
    {{- else }}
        {{/* Unknown content type - body is pre-marshaled []byte */}}
        w.WriteHeader(status)
        if resp != nil && resp.Body != nil {
            _, _ = w.Write(resp.Body)
        }
    {{- end }}
    {{- else }}
    w.WriteHeader(status)
    {{- end }}
{{- else }}
    w.WriteHeader(http.StatusOK)
{{- end }}
}
{{ end }}
