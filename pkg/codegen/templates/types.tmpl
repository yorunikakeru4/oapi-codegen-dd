{{ template "header" $ }}

{{ $isParam := or (eq .SpecLocation "path") (eq .SpecLocation "query") (eq .SpecLocation "header") (eq .SpecLocation "body") (eq .SpecLocation "schema") }}
{{ $loc := str .SpecLocation }}
{{ if $isParam }}
var {{.SpecLocation}}TypesValidate = validator.New(validator.WithRequiredStructEnabled())
{{ end -}}

{{- define "typeDef" -}}
{{ $td := .type }}
{{ $config := .config }}
{{ $loc := .specLocation }}
{{ $responseErrors := .responseErrors }}
{{ $isParam := or (eq $loc "path") (eq $loc "query") (eq $loc "header") (eq $loc "body") (eq $loc "schema") }}
{{ $alias := .alias }}
{{ if not $alias}}{{ $alias = $td.Name | fst | lower }}{{ end }}

    {{ if not $config.Generate.OmitDescription}}{{ toGoComment $td.Schema.Description $td.Name }}{{ end }}
    type {{$td.Name}} {{if $td.IsAlias}}={{end}} {{$td.Schema.TypeDecl}}

    {{ if $isParam }}
    {{ if not $td.IsAlias }}
    func ({{$alias}} {{$td.Name}}) Validate() error {
    return {{$loc}}TypesValidate.Struct({{$alias}})
    }
    {{ end }}
    {{ end -}}

    {{ if $responseErrors }}
    {{- $isResponseError := index $responseErrors $td.Name }}
    {{ if $isResponseError }}
    {{ if not $td.IsAlias }}
    {{ $alias := $loc | fst | lower }}
    func ({{$alias}} {{$td.Name}}) Error() string {
        {{- if index $config.ErrorMapping $td.Name}}
        {{ $td.GetErrorResponse $config.ErrorMapping $alias }}
        {{ else }}
        return "unmapped client error"
        {{ end -}}
    }
    {{ end }}
    {{ end }}
    {{ end }}

    {{ if $td.Schema.HasAdditionalProperties }}
        {{ template "additionalProperties" (dict "typeDef" $td "alias" $alias) }}
    {{ end }}

    {{ if and $td.NeedsMarshaler (not $td.IsAlias) (not $td.Schema.HasAdditionalProperties) }}
    func ({{$alias}} {{$td.Name}}) MarshalJSON() ([]byte, error) {
        var parts []json.RawMessage

        {{/*1. Marshal the full struct via type alias (avoids recursion)*/}}
        {{- $hasNamed := false }}
        {{- range $td.Schema.Properties }}{{ if ne .JsonFieldName "" }}{{ $hasNamed = true }}{{ end }}{{ end }}
        {{ if $hasNamed }}
            type _Alias_{{$td.Name}} {{$td.Name}}
            baseJSON, err := json.Marshal((_Alias_{{$td.Name}})({{$alias}}))
            if err != nil {
                return nil, err
            }
            parts = append(parts, baseJSON)
        {{ end }}

        {{/*2. Collect inline/union parts (those WITHOUT a JSON field name)*/}}
        {{- range $td.Schema.Properties }}
            {{ if eq .JsonFieldName "" }}
            {
                b, err := runtime.MarshalJSON({{$alias}}.{{ .GoName }})
                if err != nil {
                    return nil, fmt.Errorf("{{ .GoName }} marshal: %w", err)
                }
                parts = append(parts, b)
            }
            {{ end }}
        {{- end }}

        return runtime.CoalesceOrMerge(parts...)
    }

    func ({{$alias}} *{{$td.Name}}) UnmarshalJSON(data []byte) error {
        trim := bytes.TrimSpace(data)
        if bytes.Equal(trim, []byte("null")) {
            return nil
        }
        if len(trim) == 0 {
            return fmt.Errorf("empty JSON input")
        }

        {{ if $hasNamed }}
        {{/*// 1. Decode the named JSON fields via a type alias.*/}}
        {{/*//    Union fields are tagged json:"-" so they are ignored by this step.*/}}
            if len(trim) > 0 {
                type _Alias_{{$td.Name}} {{$td.Name}}
                var tmp _Alias_{{$td.Name}}
                if err := json.Unmarshal(data, &tmp); err != nil {
                    return err
                }
                *{{$alias}} = {{$td.Name}}(tmp)
            }
        {{ end }}

        {{- range $td.Schema.Properties }}
            {{ if and .Schema.RefType}}
                {{ if .Constraints.Nullable }}
                    if {{$alias}}.{{ .GoName }} == nil {
                        {{$alias}}.{{ .GoName }} = &{{ .Schema.RefType }}{}
                    }
                {{ end }}

                if err := runtime.UnmarshalJSON(data, {{ if not .Constraints.Nullable }}&{{ end }}{{$alias}}.{{ .GoName }}); err != nil {
                    return fmt.Errorf("{{ .GoName }} unmarshal: %w", err)
                }
            {{ end }}
        {{- end }}
        return nil
    }
    {{ end }}
{{ end }}

{{ $config := .Config }}
{{ $responseErrors := .ResponseErrors }}

{{- range .Types}}{{ $td := . }}
{{ if not $td.Schema.UnionElements }}
  {{ template "typeDef" (dict "type" $td "config" $config "specLocation" $loc "responseErrors" $responseErrors) }}
{{ end }}
{{ end }}
